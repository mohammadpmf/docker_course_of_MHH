S1   E1 مقدمه دوره داکر
S1   E2 پیش نیاز دوره
S1   E3 حل مشکل اسپات پلیر
------------------------------------------------------------------------------------------------------------------------------
S2   E4 داکر چیست و چرا بهش نیاز داریم؟
لازم نیست دوباره ببینم. اما توضیحات خیلی خوبی داشت و مفهوم رو مثل همیشه خوب توضیح داد.
S2   E5 نصب داکر
نگاه نکنم. هیچ نکته خاصی نداشت. وقت کشی. خلاصه که گفت خودتون نصب کنید.
S3   E6 کاربرد ایمیج و کانتینر
توضیحات خوبی داشت. لازم نیست دوباره ببینم. اما جالب بود. نکته مهمش این بود. برای اجرای دستور توسط داکر مینویسیم داکر ران ...
مثلا:
docker run python manage.py runserver
S2   E7 مثال عملی داکر
خیلی خوب بود. دوباره هم ببینم بهتره. خلاصه دستورات رو هم مینویسم.
برای این که بتونیم ایمیج بسازیم یه فایل میسازیم به اسم Dockerfile داخل اون میگیم که چه چیزهایی رو میخوایم و چه کارهایی بکنه.
برای این که از رو داکرفایل برامون یه ایمیج بسازه، مثلا مینویسیم.
docker build -t my_image_name .
داکر بیلد که ثابت هست. -t بهش میگیم اسم ایمیجمون رو چی بذاره و در آخر بهش میگیم که داکرفایلمون کجا هست که چون تو همون پوشه داشت اجرا میکرد نقطه گذاشت. نکته ای که داره اینه که لازم نیست بهش بگیم اسم فایلمون داکرفایل هست ما آدرس جایی رو بهش میدیم که Dockerfile توش هست.
نکته خودم. وقتی دستور
docker run first_test_image رو اجرا کردم بهم ارور میداد. چون از اینپوت استفاده کرده بودم. با اجرای docker run -it first_test_image
مشکل رفع شد چون اینتر اکتیو و تعاملی بود. تو حالت اول ترمینال تعاملی نبود و اینپوت نمیتونست بگیره.
------------------------------------------------------------------------------------------------------------------------------
S3   E8 آشنایی با کرنل
لازم نیست ببینم دوباره. توضیحات خوبی داشت. اما لازم نیست.
S3   E9 دستورات پایه
docker images ایمیج هایی که روی داکرمون به صورت لوکال داریم رو نشون میده.
docker version ورژن داکر نصب شده روی سیستم رو نشون میده.
docker run -it ... به صورت اینتراکتیو یک ایمیج رو اجرا میکنه. مثلا همون اوبونتو رو وقتی میزنم docker run ubuntu اجرا میشه و چون کاری انجام نمیده تموم میشه. اما وقتی میزنم docker run -it ubuntu به صورت تعاملی میرم توش و دیگه تو اوبونتو هستم.
چند تا دستور لینوکسی هم این وسط بنویسم:
ls برای لیست کردن. فلگ هم میشه بهش داد. مثلا ls -a که فایل های مخفی رو هم نشون میده یا ls -b یا ls -1 یا ls -l و غیره.
history برای آوردن دستوراتی که زدیم. cd که بلدم. pwd print working directory هست.
whoami برای این که بگه چه یوزری هستم. (هو اَم آی)
برای آدرس دهی مطلق در cd هم میتونیم اول اسلش رو بزنیم. میره از تو روت شروع میکنه.
S3  E10 تغییر مسیر در لینوکس
دستور docker ps پراسس های داکر رو نشون میده. یعنی کانتینرهایی که در حال اجرا هستند.
docker ps -a پراسس های داکر که قبلا ران شده بودند رو هم نشون میده. البته فعلی ها رو هم نشون میده.
S3  E11 نصب کردن پکیج جدید
دستورات لینوکس هست بیشتر این فیلم. اما مهم و جالب که بلد نبودم. راجع به فولدر bin لینوکس توضیح داد که جالب بود و گفت که برنامه ها چه طوری اجرا میشن.
برای دیدن کمک هم میشه اسم دستور رو نوشت و بعد دش دش هلپ. غیر از دستور اکو که چاپش میکنه 😂 برای این و دستورای بیلت این مشابه باید بنویسیم help echo
برای نصب مینویسیم apt install اسمش. منتهی این لینوکسی که ما نصب کردیم همه پکیج ها رو نمیشناسه و آپدیت نیست. با apt list هم میتونیم وضعیت پکیج ها رو ببینیم. با apt update وضعیتشون رو به صورت لوکال آپدیت میکنه. بعد دوباره اگه apt list بزنیم میبینیم که ۸۰ برابر پکیج بهمون نشون میده. خلاصه پایتون ندارم. اما الان با apt install python3 نصب میشه. دقت کنم که ورژن ۳ هم مهمه. البته نذاشتم ارور داده بود. احتمالا دنبال ۲ میگشت که دیگه آپدیت نداشت و اینم بی خیال شد. در کل ویدیو خیلی خوبی بود.
S3  E12 ساخت و اجرای فایل پایتون
دستور touch لینوکس که اینم یک نرم افزار هست، باهاش میشه فایل ساخت. تمرین کرد تمرین نصب nodejs رو داد. جالب بود. در کل ویدیو خیلی خوبی بود.
S3  E13 استفاده از نانو
بد نبود. برای حذف یک برنامه apt remove esme_barnameh.
S3  E14 کار با فایل ها
دستورات بیشتر لینوکسی
mv دستور انتقال در لینوکس
rm دستور حذف فایل در لینوکس
rm -r به صورت ریکرسیو پاک میکنه.
rm -rf به صورت ریکرسیو هست و فورس هم میکنه. 😁
cat file کل اطلاعات داخل فایل رو میخوونه.
head file_name -n 4 فقط ۴ خط اول فایل رو میخونه.
tail file_name -n 8 فقط ۸ خط آخر فایل رو میخونه.
more file_name فایل رو میخونه ولی صفحه اولش رو فقط نشون میده. اسپیس رو بزنیم میره صفحه بعد و ...
یه برنامه دیگه هم درست کردن به اسم less که باید نصبش کرد این قابلیت بالا بردن هم داره 😁 دیگه نصبش نکردم.
S3  E15 اجرای مجدد یک کانتینر
با دستور docker start image_id_of_container میتونیم یه کانتینر رو دوباره اجرا کنیم. البته اگه تعاملی میخوایم docker start -i image_id.
البته از بین ایمیج آی دی های لوکال میاره. به خاطر همین لازم نیست کامل بنویسیم. اگه ۳ ۴ تا حرف اول ایمیج رو بنویسیم و تکراری نباشه خودش میفهمه که کدوم رو باید ران کنه.
S3  E16 متغیرهای محیطی
دستور printenv در لینوکس تمام متغیرهای محیطی رو نشون میده.
اگه متغیر محیطی خاصی رو هم بخوایم مثل PATH میتونیم بنویسیم printenv PATH یا هر چیز دیگه ای که در این حالت فقط مقدار اون رو برامون مینویسه. (بدون خود کلیدی که ما گفتیم)
با دستور export HARCHI=harchi_ke_delam_mikhad متغیر محیطی HARCHI به طور موقت اضافه میشه به متغیرهای محیطی. دائم چه طوریه. الان میگم. قبلش توضیح داره. برای رفتن به پوشه home برای هر اکانت در لینوکس میتونیم از تیلدا استفاده کنیم. cd ~ ما رو میبره به دایرکتوری home. توی home یه فایل هیدن داریم به اسم .bashrc که داخل اون متغیرهای محیطی نوشته شدند. و وقتی ترمینال باز میشه از این تو متغیرهای محیطی رو میخوونه. میتونیم به این فایله اضافه کنیم. حالا با اکو یا نانو یا هرچیزی. نکته ای که داره اینه که وقتی اضافه میکنیم همون لحظه نمیشناسه. چون موقع باز شدن ترمینال که اون موقع نبود این فایل رو خوونده بود. اگه از لینوکس بیام بیرون و دوباره برم توش اوکی هست. اما اگه نخوایم ترمینال رو ببندیم و دوباره باز کنیم میتونیم با دستور سورس اجراش کنیم که مجدد متغیر های محیطی رو آپدیت کنه. مثلا source .bashrc که دوباره اجراش میکنه. البته با فرض این که تو home باشم. اگه نباشم که میشه با نوشتن source ~/.bashrc اجراش کنم. نکته آخر هم اینکه برای نشون دادن متغیرهای محیطی ای که اضافه کرده بود از echo $env_name استفاده کرد. منم کردم جواب داد. اما printenv env_name برای متغیرهایی که خودم اضافه کردم چیزی نمیاورد.
نکته بعد از ویدیو. اشتباهی یه بار نوشتم cd خالی و چیزی ننوشته بودم. خودش ما رو میبره به home یعنی ~
S3  E17 استفاده از grep
مخفف global regular expression print هست. برای سرچ کردن. نحوه استفاده ازش این طوریه. grep matni_ke_mikhaym file_i_ke_toosh_mikhaym_begarde
حالا اگه بخوایم اینسنسیتیو باشه یه -i به عنوان فلگ به گرپ میدیم. اگه چیزی هم که دنبالش میگردیم عبارت هست میتونیم از کوتیشن یا دابل کوتیشن دورش استفاده کنیم. برای سرچ در چند تا فایل هم بعد از نوشتن اسم فایل اول، فایل دوم و بقیه رو میدیم و به تفکیک فایل میگه که چی پیدا کرده.
اگه بخوایم تو فولدر بگرده grep matn dir_name/ رو وقتی مینویسیم ارور میده میگه دایرکتوری هست. باید بهش بگیم ریکرسیو بگرده یعنی grep matn -r dir_name/ و این طوری اون دایرکتوری رو میگرده. grep matn -r . هم تو همین پوشه فعلی میگرده.
S3  E18 پیدا کردن فایل با نام
برای پیدا کردن فایل یا دایرکتوری با نام خاص از دستور find استفاده میشه. find خالی میاد تمام فایل ها و دایرکتوری ها و فایل های داخل دایرکتوری ها و دایرکتورهاش رو و ... رو به صورت ریکرسیو به ما میده. اما میتونیم از فلگ -type d استفاده کنیم که فقط دایرکتوری ها رو بده یا از فلگ -type با مقدار f استفاده کنیم که فقط فایل ها رو بده. اگه بخوایم بر اساس نام باشه از فلگ -name استفاده میکنیم بعدش هم قاعدتا اسم فایل رو میدیم. حالا اگه ندونیم میتونیم از re استفاده کنیم. مثلا find -name "*.py" تمام فایل های پایتون رو میده. (دایرکتوری ننوشتم چون اغلب برای دایرکتوری پسوند py نمیذاریم 😁 اما اگه فلگ -type رو با مقدار f بهش ندم خودش هم فایل و هم دایرکتوری ها رو میگرده.) یا find -name "main*" تمام فایل و دایرکتوری هایی که با کلمه main شروع شدن رو میده.
S3  E19 استفاده از پایپ
جالب بود. برای ترکیب سرچ و grep خیلی استفاده میشه. کوتاه بود. کار کنم دستم میاد. خلاصه اش اینه که ما میتونیم بهش بگیم یه سری فایل و دایرکتوری رو پیدا کنه. بعد به جای این که پرینت کنه، یه پایپ میذاریم و بعدش مثلا گرپ رو مینویسیم. در واقع خورجوی چپی رو به عنوان ورودی راستی میده. مثلا cat main.txt | grep fallh کل فایل main.txt رو میخوونه و توی اون دنبال fallah میگرده و به ما جواب میده.
S3  E20 ساخت یوزر جدید
با دستور useradd username میشه یوزر جدید ساخت. مثلا یکی Mohammad ساختم. که بیچاره home هم نداشت و به هیچ جایی دستش بند نبود. نه میتونستم فایل بسازم نه دایرکتوری. فقط بعضی جاها رو با cd میتونستم ببینم. با دستور useradd -m username یه دایرکتوری تو home براش میسازه. مثلا یکی هم madval ساختم. با این یکی توی home که رفتم، یه پوشه به اسم madval بود که داخل اون میتونستم فایل یا دایرکتوری بسازم و داخلش چیز بنویسم. یا مثلا فایل پایتون ساختم و با برنامه پایتون اجراش کردم. ولی وقتی از دایرکتوری madval یکی برمیگشتم عقب یعنی تو home. اونجا ubuntu رو میدیدم. اما اجازه نداشتم داخلش حتی cd بکنم. حالا چه طوری من اصلا با یوزرهای دیگه کار کردم. بریم قسمت داکرش:
با دستور docker exec میتونیم یه دستوری رو بگیم که اجرا کنه. مثلا الان میخوایم با همین یوزر جدید وارد بشیم. منتهی برای این که اینتر اکتیو باشه از فلگ it هم استفاده میکنیم. در واقع اول نوشتم docker exec ee0 bash که ee0 شماره کانتینرم بود و بش هم که اسم ترمینال لینوکس هست. بهش گفتم که تو کانتینر ee0 بش رو اجرا کن. اما چون اینتراکتیو نبود خارج شد. بعد نوشتم docker exec -it ee0 bash که ترمینال رو داشتم. منتهی با یوزر روت وارد شد. میتونیم با فلگ -u بهش بگیم که چه یوزری باشه. مثلا با دستور docker exec -it -u Mohammad ee0 bash با یوزر محمد وارد شدم. اگه یوزری روت نباشه، قبل از دستورات علامت دلار میذاره. برای روت هشتگ میذاشت.
نکته آخر. دستور userdel برای پاک کردن یک یوزر هست. که قاعدتا اسم یوزر رو به عنوان ورودی بعدی به دستورش میدیم.
S3  E21 ساخت گروه
با دستور groupadd group_name میتونیم یه گروه بسازیم. مثلا groupadd devops گروه برای دواپس میسازه.
با دستور usermod -G groupname username میتونیم یوزر رو مدیفای کنیم و گروه groupname رو دسترسیش رو به یوزر username بدیم.
با دستور groups username میتونیم گروه هایی که اون یوزرنیم عضوش هست رو ببینیم.
نکته. برای هر یوزری که میسازیم خود لینوکس یه گروه هم به اسم اون یوزر میسازه. مثلا یه گروه به اسم madval هم داریم که خود لینوکس بعد از ساخت یوزر madval ساختتش.
S3  E22 مدیریت دسترسی ها
وقتی ls -l میزنیم. سمت چپ اطلاعاتی که مینویسه به صورت مقابل هست. drwxrwxrwx حرف اول نشان دهنده نوع فایل یا دایرکتوری هست. d یعنی دایرکتوری هست. اگه - باشه یعنی فایل هست. بعضی ها هم l بودند سرچ که کردم دیدم c, b, p, s هم داریم که توضیحشون رو نمینویسم 👏
۳ حرف بعدی میگه دسترسی read و write و execute سازنده ی اون فایل یا دایرکتوری چی باشه. هر کودوم که خود حرف باشه یعنی اون دسترسی رو داره. هر کودوم که - باشه یعنی اون دسترسی رو نداره. ۳ تای بعدی هم همین طور. منتهی برای گروه. ۳ حرف آخر هم همین طور منتهی برای others. یعن کسی که نساختتش و جزو اون گروه هم نیست چه کاری بتونه بکنه. برای دایرکتوری ها execute یعنی این که بتونه بره داخلش یا نه.
حالا این شد از نحوه خووندنش. نحوه تغییر چه طوری هست. از دستور chmod که چنج مد هست استفاده میکنیم. chmod u+x some_file_or_som_directory یعنی برای گروه یوزر (همون کاراکترهای ۲ تا ۴ یعنی کسی که ساخته.) دسترسی اکزکیوت رو اضافه کن. u اول نشان دهنده یوزر هست. اگه g بذاریم میشه گروپ یعنی ۵ تا ۷ و o برای others هست. اگه o بذاریم یعنی ۸ تا ۱۰ رو تغییر بده. + یعنی اضافه کنه دسترسی رو. - هم میشه گذاشت یعنی کم کنه. آخرین حرف هم که نوع دسترسی هست. همزمان هم میشه نوشت. مثلا chmod ugo+rwx test.sh main.pyاجازه همه کار روی فایل test.sh و main.py رو به همه میده.
------------------------------------------------------------------------------------------------------------------------------
S4  E23 نمونه پروژه واقعی
S4  E24 درخواست از شما دوست عزیزم
S4  E25 اجرای پروژه در حالت واقعی
S4  E26 استفاده از ایمیج مناسب
یادآوری. بعد از ساخت داکرفایل، برای ساختن ایمیج از روش دستور docker build -t esme_image_i_ke_mikham . رو زدم که برام ایمیج رو بسازه و با نقطه آخر بهش گفتم از رو داکر فایلی که تو همون پوشه وی اس کد درست کرده بودم گفتم میخوام استفاده بشه. یعنی Dockerfile من اینجاست. برای ران کردنش docker run esmi_ke_baraye_image_am_gozashe_boodam رو زدم. منتهی بسته میشه. از طرفی وقتی فلگ -it رو زدم مستقیم میرفت تو خود پایتون. چون نسخه آلپاین که نصب کرده بودم اون شکلی بود. برای این که بره تو ترمینالش، تهش نوشتیم sh. یعنی این شکلی شد.
docker run -it django-application-sample sh که با این دستور دیگه تو پایتون نرفت و شل رو اجرا کرد.
S4  E27 کپی فایل ها در داکر فایل
ویدیو خیلی خوبی بود. در مورد دستور COPY کلی توضیح داد. دیگه اینجا چیزی ننوشتم. باز حتما ببینم بعدا.
S4  E28ایگنور کردن فایل ها
قشنگ بود.
S4  E29اجرای دستورات در هنگام بیلد
با دستور RUN تو داکرفایل میتونیم بهش بگیم که توی لینوکس چه دستوری رو توی بش اجرا کنه. مثلا RUN pip install -r /app/requirements.txt بهش میگیم که بره نیازمندی های پروژه رو نصب کنه.
S4  E30 تعیین مکان اصلی پروژه
برای این که داخل داکر فایل همه جا هی موقع آدرس دهی ننویسیم /app/... ، به جاش با دستور WORKDIR میگیم که مکان دیفالتی که بش رو باز میکنه وقتی که داکرفایل رو میسازه کجا باشه. وقتی میگیم WORKDIR /app، بعدش وقتی وارد بش میشه تو دایرکتوری اپ هست. پس برای کپی کردن فایل هامون مینویسیم COPY . . و یا برای نصب نیازمندی ها مینویسیم RUN pip install -r requirements.txt چون داخل همون دایرکتوری app هستیم.
S4  E31 ویدئوی مهم - cmd + port mapping
در مورد دستور CMD گفت. دستور RUN در زمان بیلد ایمیج اجرا میشه. به خاطر همین نصب نیازمندی ها رو اون موقع انجام میدیم. اما دستور python manage.py runserver رو هم اگه با RUN بنویسیم، موقع بیلد کردن اجراش میکنه و تا ابد توش گیر میکنه. برای این که بگیم در زمان RUN کردن داکر و نه زمان بیلد کردن ایمیج دستوری رو اجرا کنه، از دستور CMD استفاده میکنیم. پس بهش میگیم CMD python manage.py runserver 
ویدیو طولانی و مهمی بود که همه رو ننوشتم. نکته آخرش این که ENTRYPOINT هم مثل CMD عمل میکنه. با این تفاوت که فقط یه دونه ازش میذاریم. CMD رو میشه چند بار نوشت. و موقع اجرا بهش با فلگ یا چیزای دیگه ورودی هم داد. انتری پوینت سخت گیرانه تر هست. اما اگه همیشه کانتینرمون بخواد یه کار خاص رو انجام بده، بست پرکتیس نوشتن انتری پوینت هست. ترکیبی هم میشه نوشت که اینا رو دیگه از AI پرسیدم. انشالله کار کنم بیشتر بعدا باهاشون آشنا میشم. اما در کل ویدیو مهم و خوبی بود.
S4  E32 جلوگیری از دسترسی غیر مجاز
مهم بود. دوباره ببینم.
S4  E33 جایگاه درست دسترسی در داکرفایل
مهم بود. دوباره ببینم.
S4  E34 ویدیو مهم - آپتیمایز کردن ایمیج ها
خیلی جالب بود. دوباره ببینم. ساده بود ولی جالب.
S4  E35 تگ ها
خیلی فعلا به کار نمیاد. به خاطر همین یادداشت برداری نکردم. نکته مهمش اینه که موقع بیلد کردن آخر اسمش یه دو نقطه بذاریم و بعد ورژن بزنیم خوبه. مثلا docker build -t mohammadpmf/madval:v2 . که ایمجی به اسم mohammadpmf/madval میسازه با تگ v2. این رو با توجه به ویدیو های بعدی گذاشتم. چون اکانت داکرهابم mohammadpmf بود و ریپازیتوری ای که برای تست ساختم madval بود. و ۲ تا ورژن روش گذاشتم. این یکی مثلا بیلدی بود که برای دومی زدم. ۲ تا ویدیو بعدی رو که دیدم بهتر درک کردم. اما باز بعدا برگردم سراغ این ویدیو ها.
S4  E36 داکرهاب و پوش روی آن
جالب بود. یه دونه پابلیک گذاشتم. کلا برای شخصی یه پرایویت میشه گذاشت. اما پابلیک بیشتر میشه. ولی دقت کنم مثل گیت هاب نیست. بذارم همه کل پروژه من رو دارن 😁
S4  E37 ذخیره آزادانه ایمیج ها
جالب بود. باز هم ببینم. با دستور docker save -o harchi.tar image_name:image_vesion میتونیم کل ایمیج رو به فایل .tar تبدیل کنیم.
و با دستور docker load -i harchi.tar میتونیم ایمیج رو به داکرمون اضافه کنیم. دقت کنم که حجم ایمیج من ۱۳۸ مگ بود. اما فشرده شده اش با پسوند .tar خیلی کمتر شده بود. (۳۴ مگ)
------------------------------------------------------------------------------------------------------------------------------
S5  E38 پروژه واقعی دیگر
S5  E39 مدیریت کانتینرها
با اجرای دستور docker run -d container_name میتونیم بگیم به صورت دیتچد اجرا کنه که ترمینالمون آزاد باشه بتونیم باهاش کار بکنیم. حالا چه جوری وضعیت کانتینر در حال اجرا رو ببینیم؟ با دستور docker ps وضعیتش رو به ما نشون میده. اینم مهم نیست ولی با --name naem_of_container میتونیم بهش اسم دلخواه خودمون هم بدیم. اگه ندیم خودش دیفالت یه اسمی براش میذاره. فقط دقت کنم که اسم هایی که از قبل بوده رو نمیتونم استفاده کنیم.
برای قطع کردن کانتینری که داره اجرا میشه (انگار مثلا رو سرورمون داره اجرا میشه میخوایم خاموشش کنیم) مینویسیم docker stop container_id که البته آی دیش رو ۲ ۳ تا حرف هم بنویسیم اوکیه. ۳ تایی اوکی بود. ولی ۲ تایی رو یه بار که نوشتم میگفت که چند تا کانتینر دارم که با این حرف شروع میشن. اما در کل لازم نیست کلش رو بنویسیم خودش با شعوره و میفهمه 😁 برای اجرای مجدد همون کانتینر (انگار مثلا همون کامپیوترمون رو میخوایم روشن کنیم) مینویسیم docker start container_id.
S5  E40 لاگ گرفتن از کانتینر
برای دیدن لاگ کانتینر وقتی که تو حالت دیتچد اجرا شده میتونیم با docker logs container_id لاگ های تا اون لحظه اش رو ببینیم. اگه بعدش خواستیم لاگ های بعدی رو بگیریم دوباره همین دستور رو مینویسیم. برای این که یه بار بنویسیم از -f میتونیم استفاده کنیم که لاگ ها رو فالو کنه. ولی خب ترمینالمون موقتا نمیشه دستور دیگه ای نوشت توش. برای دیدن زمان هاشون یا مثلا ۲ تای آخر و ... هم از docker logs --help استفاده کرد که جالب و آسون بود دیگه اینجا ننوشتم.
S5  E41 نکته
S5  E42 پاکسازی
برای پاک کردن کانتینر از دستور docker container rm container_name_or_container_id استفاده میکنیم. البته برای این میشه نوشت docker rm container_name_or_container_id و کار میکنه. اما ننویسم بهتره. چون تازه یاد گرفتم با نوشتن container برای خودم مشخص تر میشه که میخوام کانتینر رو پاک کنم و نه ایمیج رو. خلاصه. تعدادشون زیاد بود. میشه با docker container prune همه رو پاک کرد که میپرسه میگه همه کانتینرهایی که در حال ران نیستند پاک میشن مطمئنی؟ و میتونیم تایید کنیم. اگه یه ضرب میخوایم پاک کنه که میتونیم -f رو هم بزنیم. دقت کنم که کانتینرهایی که خاموش هستند رو پاک میکنه. برای حذف در حال اجراها باید خودمون با docker container rm این کار رو بکنیم. نکته آخر که اشتباها اول docker prune نوشته بودم که کار نکرد. پس کلا از docker container ... استفاده کنم بهتره.😊
S5  E43 اجرای دستورات در کانتینر
اگه بخوایم بریم داخل ترمینال داکر یه دستوری رو بزنیم چی کار باید کرد؟ با دستور docker exec container_name_or_container_id echo hello میتونیم بهش بگیم که بره داخل اون کانتینر و دستور echo hello رو اجرا کنه. حالا هر دستور دیگه ای هم بخوایم میتونیم بهش بگیم. در واقع بهش میگیم داخل کانتینر یک دستوری رو اگزکیوت کنه. منتهی اگه کارمون طولانی باشه چی. بخوایم جا به جا بشیم بریم توش از نانو استفاده کنیم و غیره. منظورم اینه که هربار اولش docker exec رو ننویسیم. میگیم docker exec -it container_name_or_container_id sh که بهش میگیم شلش رو به صورت اینتراکتیو برامون باز کنه. بعد راحت کارمون رو میکنیم.
S5  E44 ویدئوی بسیار مهم - والیوم ها
در کل ویدیو جالبی بود. دوباره ببینم بعدا. اما خودم هم تست کردم و کلی توضیح دارم. توضیح اینه که وقتی ما کانتینرهای مختلف رو از یه ایمیج میسازیم، خب هر کودوم جداست و به هم دسترسی ندارن. مثلا تو یه کانتینر عکسهای یوزر رو میگیریم و تو یه پوشه ذخیره میکنیم. اما خب بقیه بهش دسترسی ندارن. حالا میخوایم اینا رو به هم وصل کنیم. در واقع اینا رو به هم وصل نمیکنیم. یه کانتینری که میخوایم بسازیم بهش میگیم که یه قسمتی از دم و دستگات 😁 اشتراکی هست. چون در عمل هم دیدم که میاد بیرون از کانتینر ها یه بخش والیوم میسازه و توی داکردستکاپ هم خودم دیدم. خب خلاصه اینه که یه والیوم میسازیم و موقع ساخت کانتینر با دستور docker run ... بهش میتونیم والیوم هم بدیم. بهش میگیم که توی داکر سیستممون، چه دایرکتوری ای رو به دایرکتوری داخلی اون کانتینر وصل کنه. مثلا بهش گفتم
docker run -p 8000:8000 -v harchi:/app/users-data --name v0 -d mohammadpmf/madval:v2 یعنی برو یه کانتینر بساز که پورت ۸۰۰۰ سیستم من رو به۸۰۰۰ کانتینر وصل کنه و دایرکتوری ای به اسم harchi رو به دایرکتوری داخل کانتیر به اسم users-data که داخل دایرکتوری app اون کانتینر هست وصل کنه. اسمش v0 باشه و از روی اون ایمیج بسازه. خب حالا وقتی این کانتینر ران میشه. چیزهای لوکالش مال خودش هست. اما چیزایی که داخل دایرکتوری users-data دستکاری میشن به والیوم بیرون اون کانتینر یعنی به داکر من متصل هستند. و این طوری میتونیم تغییرات رو جاهای دیگه هم ببینیم. مثلا من زدم.
docker run -p 8000:8000 -v harchi:/app/users-data --name v0 -d mohammadpmf/madval:v2
docker run -p 8001:8000 -v harchi:/app/users-data --name v1 -d mohammadpmf/madval:v2
docker run -p 8002:8000 -v harchi:/app/users-data --name v2 -d mohammadpmf/madval:v2
docker run -p 8020:8000 --name dj0 -d mohammadpmf/madval:v2
docker run -p 8021:8000 --name dj1 -d mohammadpmf/madval:v2
docker run -p 8022:8000 --name dj2 -d mohammadpmf/madval:v2
از رو همون ایمیج ۶ تا کانتیر ساختم. ۳ تا کانتینر ساختم که با نام های dj شروع میشن و کلا مستقل هستند از همه جا. هر کاری تو هر کودومشون بکنیم فقط تو خودشون هست. ۳ تا هم ساختم که با نام های v شروع میشن. داخلشون مستقل هست از بقیه کانتینر ها به جز دایرکتوری users-data شون که هر غلطی توشون بکنیم 😁 ۲ کانتینر دیگه هم میتونن ببینن.
نکته آخر. با دستور docker volum -ls میتونیم والیوم ها رو ببینیم. چون بخش مهمی هست تو داکر دسکتاپ خودش اصلا یه تب جدا داره که از بیرون هم میتونیم تغییرشون بدیم یا ببینیم و باهاشون کار کنیم.
S5  E45 انتقال فایل از و به کانتینر در حال اجرا
دستورش docker cp هست که فایل یا دایرکتوری رو کپی میکنه. docker cp source dist. تو حالت انتقال فایل از سیستم ما به کانتینر سورس که سیستم خودمون هست و معمولا از همون دایرکتوری ای که داریم کار میکنیم منتقل میکنیم و آدرس دهیش آسون هست. برای مقصد اول اسم یا آی دی کانتینر رو مینویسیم و بعد : میذاریم و بعد آدرس دهی میکنیم. مثلا docker cp mmm dj0:/app/users-data یعنی دایرکتوری mmm رو ببره به داخل اون کانتینر و داخل ان پوشه بذاره. برای برعکس سورس آدرس توی کانتینر هست. اسم کانتیر و بعد : و بعد آدرس. و مقصد هم که سیستم خودمون هست. مثلا docker cp dj0:app/users-data/test.txt . رو زدم که فایل رو از تو کامپیوتر آورد توی ویندوز من. کانتینر به کانتیر رو تست کردم خودش نوشت که copying between containers is not supported 😁
نکته. اگه مثلا یه فایل مهم پایتونی رو اجرا کردیم و نمیخوایم کانتینر رو قطع و دوباره وصل کنیم با دستور docker container restart container_name_or_container_id میتونیم بگیم از اول اجراش کنه.
S5  E46 انعکاس لحظه ای تغییرات در کانتیر در حال اجرا
جلوتر قراره داکر کامپوز رو یاد بگیریم که تو پروژه های واقعی استفاده میشه. اما برای توسعه و این که تغییرات کدمون در لحظه توی کانتینرمون هم اعمال بشه میتونیم موقع ران کردن کانتینر مثلا بنویسیم
docker run -p 8010:8000 -d -v "$(pwd)":/app --name v10 mohammadpmf/madval:v2
البته برای من میگفت دستور pwd رو نمیشناسه. تو ویندوز باید دستور cd رو به جاش نوشت. اما این هم جواب نداد. چون داخل مسیر ابسلوت من از کاراکترهای فارسی استفاده شده بود. خلاصه برای اینکه کار کنه من آدرس داینامیک رو که خودش از سیستم عامل بگیره بیخیال شدم و گفتم.
docker run -p 8010:8000 -d -v .:/app --name v10 mohammadpmf/madval:v2
این طوری بهش میگیم که در واقع به جای این که داخل کانتینر بیاد فایل ها رو کپی کنه، داخل یه والیوم اطلاعات رو بذاره و این کانتینر هم بهش دسترسی داشته باشه. از طرفی گفتم همین پوشه فعلی. پس من از داخل ویندوز تغییرش میدم و کانتینر من میتونه ببینتش. و چون سرور جنگو دائم داره اجرا میشه، تغییرات رو میبینه و سایتمون آپدیت میشه. البته جهت تست و فضولی، رفتم داخل ستینگز و یه چیز الکی نوشتم که ارور بده و ۲ ۳ ثانیه بعد دیگه سایت کار نمیکرد. اما بعدش هم که برداشتم باز کار نمیکرد. دلیلش اینه که وقتی تو ستینگز manage.py ارور میده دیگه باید سرور رو قطع کرد و دوباره اجراش کرد. که این کار رو کردم و درست شد. یه بار دیگه هم تست کردم و با docker restart v10 هم زدم درست شد. منتهی در حالت کلی هم یادم باشه وقتی دارم توسعه میدم چون اتوسیو من فعال هست. احتمالا در لحظات زیادی سرور جنگو ارور میده که همون طور که دیدم تو خیلی از حالت ها دیگه خودش نمیتونه وصل بشه و باید قطع و وصل کنم. پس اگه این کار رو برای پروژه ای کردم باید docker restart container_name_or_container_id رو بزنم که بتونم ادامه بدم پروژه رو.
------------------------------------------------------------------------------------------------------------------------------
S6  E47 پروژه جدید
S6  E48 اتصال بک اند و دیتابیس
تقریبا مطالب تکراری بود و لازم نیست ببینم دوباره. نکته مهمش اینه که من میتونم کل پروژه جنگوم رو عادی باهاش کار بکنم. تو یه کانتینر فقط سلری رو بالا بیارم که تو ویندوز هم باهاش مشکل نداشته باشم.
S6  E49 اتصال دیتابیس به جنگو
ویدیو خیلی جالبی بود. پستگرس ۱۵ رو گرفتیم رو یه کانتینر ران کردیم و از تو ویندوز بهش وصل شدیم و خیلی راحت کار کردیم. باز هم ببینم بد نیست. مفهومی و جذاب بود. خلاصه رو سیستم خودم چون پستگرس داشتم و میخواستم بعدا مشکل ایجاد نکنه، پورت رو عوض کردم. این دستور رو زدم.
docker run -d --name postgres -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=django_db -p 5555:5432 -v postgres_data:/var/lib/postgresql/data postgres:15
که گفتم پستگرس ورژن ۱۵ رو میخوام. چون ایمیجش نبود آنلاین دانلودش کرد و ایمیجش دیگه رو سیستمم هست. دفعات بعد دیگه ایمیجش رو دانلود نمیکنه. بقه - ها و -- ها رو که بلدم. -e هم که آسونه. برای ست کردن یوزرنیم و پسورد و اسم دیتابیس استفاده شده. 
S6  E50 اجرای رایگان n8n
جالب بود. رو سیستمم راه انداختم. دستورش رو اینجا مینویسم که داشته باشم.
docker run -it --rm --name n8n -p 5678:5678 -e GENERIC_TIMEZONE="Asia/Tehran" -e TZ="Asia/Tehran" -e N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true -e N8N_RUNNERS_ENABLED=true -v n8n_data:/home/node/.n8n docker.n8n.io/n8nio/n8n
------------------------------------------------------------------------------------------------------------------------------
کل این فصل رو یکبار سریع دیدم و بعضی از کارها رو انجام دادم. مهم ترین نکته اینه که docker-compose به همراه docker نصب میشه. اما یه برنامه جدا هست که نقش چسب رو داره. در واقع تو فایل docker-compose.yml یا docker-compose.yaml بهش میگیم که چی ها رو اجرا کنه با کلی آپشن که توش داریم و با یک دستور docker-compose up همه رو برامون اجرا میکنه. فصل جالبی بود. اما فکر کنم خودش زودتر میخواست دوره رو منتشر کنه و عجله داشت و سر ادیت یه کم کم کاری کرد. با این حال مطالبی که گفت خوب بود. من یادداشت ننوشتم. اما حتما دوباره ببینم همه قسمت هاش رو. تمام دستوراتی که برای داکر داشتیم برای داکر کامپوز هم داریم. مثلا
docker exec		->	docker-compose exec
docker ps		->	docker-compose ps
docker build	->	docker-compose build
و غیره
S7  E51 پروژه جدید
S7  E52 اجرای دستی پروژه
S7  E53 فرمت yml
S7  E54 نیاز به داکر کامپوز
S7  E55 نصب و راه اندازی داکر کامپوز
S7  E56 پیکربندی یک فایل کامپوز
S7  E57 اضافه کردن بک اند
S7  E58 بررسی سلامت اجرای یک کانتیر
S7  E59 اضافه کردن داده های جنگو
S7  E60 اضافه کردن والیوم
S7  E61 بیلد کردن با داکر کامپوز
S7  E62 نتورکینگ در داکر کامپوز
S7  E63 پورت در برابر شبکه داخلی
خیلی جالب بود.
S7  E64 لاگ گرفتن از کانتیرها
S7  E65 داکر ایگنور در داکر کامپوز
S7  E66 توسعه همزمان با داکر کامپوز
------------------------------------------------------------------------------------------------------------------------------